# RP8086 - Чипсет i8086 на базе RP2040

## Описание проекта

RP8086 - это программно-аппаратный комплекс, использующий китайскую фиолетовую плату RP2040 (Raspberry Pi Pico) в качестве чипсета для процессора Intel 8086. RP2040 эмулирует:

- ✅ Контроллер системной шины (PIO hardware)
- ✅ Эмулятор ROM (8KB GlaBIOS)
- ✅ Эмулятор RAM (64KB)
- ✅ I/O контроллер
- ✅ Генератор тактового сигнала (PWM, 33% duty cycle)

**Преимущество**: RP2040 толерантна к 5В на входе, поэтому дополнительные level shifters не требуются для прямого подключения к i8086.

**Статус**: Фаза 1 завершена - минимальный рабочий прототип готов к тестированию на железе.

## Архитектура

### Используемые компоненты

1. **PIO (Programmable I/O)** - аппаратный контроллер шины
   - Обрабатывает все операции чтения/записи на аппаратном уровне
   - Управляет сигналами READY (wait states)
   - Минимальные задержки благодаря hardware timing

2. **ARM Cortex-M0+** - обработчик данных
   - Обрабатывает прерывания от PIO
   - Эмулирует память и I/O порты
   - Работает с критичным по времени кодом (`__time_critical_func`)

### Назначение GPIO

| GPIO | Сигнал | Направление | Описание |
|------|--------|-------------|----------|
| 2 | ALE | Вход | Address Latch Enable - защелка адреса |
| 3 | CS | Вход | Chip Select - выбор чипа |
| 6 | WR | Вход | Write - сигнал записи |
| 7 | RD | Вход | Read - сигнал чтения |
| 8-15 | D0-D7 | Двунаправленная | Шина данных (8 бит) |
| 20 | READY | Выход | Управление wait states для CPU |
| 21 | INT | Выход | Прерывание для CPU |
| 22 | LED | Выход | Светодиод состояния |
| 29 | CLK | Выход | Тактовый сигнал для i8086 (TODO) |

## Протокол работы шины

### Цикл чтения (RD)

1. CPU активирует CS (Chip Select)
2. CPU выставляет адрес и активирует ALE
3. PIO защелкивает адрес и поднимает сигнал WAIT (READY = 1)
4. CPU активирует RD
5. PIO генерирует прерывание IRQ1
6. ARM обрабатывает чтение и возвращает данные через FIFO
7. PIO выставляет данные на шину и опускает WAIT (READY = 0)
8. CPU считывает данные
9. CPU снимает RD
10. PIO переводит шину данных в Z-состояние

### Цикл записи (WR)

1. CPU активирует CS (Chip Select)
2. CPU выставляет адрес и активирует ALE
3. PIO защелкивает адрес
4. CPU выставляет данные на шину и активирует WR
5. PIO ждет установки данных (7 циклов)
6. PIO считывает данные и генерирует прерывание IRQ0
7. ARM обрабатывает запись
8. CPU снимает WR

## Текущая реализация

### Эмулируемые I/O порты

В данный момент реализована демонстрационная эмуляция I/O портов с генератором последовательности Фибоначчи:

| Порт | Режим | Описание |
|------|-------|----------|
| 0x00 | R/W | Младший байт числа Фибоначчи / Сброс последовательности |
| 0x01 | R | Старший байт числа Фибоначчи |
| 0x04 | R | Тестовое значение 0x45 |
| 0x05 | R | Тестовое значение 0x23 |

#### Пример использования (x86 Assembly)

```assembly
; Сброс последовательности Фибоначчи
mov al, 0
out 0, al

; Чтение текущего числа Фибоначчи (16 бит)
in al, 0      ; Младший байт
mov bl, al
in al, 1      ; Старший байт
mov bh, al    ; bx = число Фибоначчи

; Каждое чтение из порта 0 продвигает последовательность
in al, 0      ; Следующее число
```

## Структура проекта

```
RP8086/
├── main.c              # Точка входа, инициализация системы
├── cpu.c/h             # Управление i8086 (clock, reset)
├── cpu_bus.c/h         # Контроллер шины, эмуляция памяти
├── i8086_bus.pio       # PIO программа контроллера шины
├── config.h            # Конфигурация GPIO и системы
├── bios.h              # GlaBIOS ROM образ (8KB)
├── CMakeLists.txt      # Конфигурация сборки
├── README.md           # Документация проекта
├── CLAUDE.md           # Документация для Claude Code
├── STATUS.md           # Текущий статус реализации
└── PIO_ANALYSIS.md     # Анализ PIO программы
```

## Ключевые функции

### cpu.c
- `start_cpu_clock()` - Генерация PWM clock для i8086
- `reset_cpu()` - RESET sequence для i8086

### cpu_bus.c
- `cpu_bus_init()` - Инициализация PIO и IRQ обработчиков
- `bus_read_handler()` - Обработчик чтения (IRQ1)
- `bus_write_handler()` - Обработчик записи (IRQ0)
- `cpu_bus_read()` - Эмуляция чтения памяти/I/O (16-bit)
- `cpu_bus_write()` - Эмуляция записи памяти/I/O (16-bit)

### i8086_bus.pio
PIO state machine с поддержкой:
- Захват 20-битного адреса через ALE
- Автоопределение RD/WR циклов
- Управление READY для wait states
- Двунаправленная 16-битная шина данных
- Генерация IRQ для ARM

## Особенности реализации

### Производительность

- **Zero-wait state доступ**: PIO обрабатывает шину без задержек
- **Hardware timing**: Все критичные операции выполняются в PIO
- **Критичный код**: Обработчики помечены `__time_critical_func` для размещения в RAM
- **Высокий приоритет**: Прерывания шины имеют `PICO_HIGHEST_IRQ_PRIORITY`

### PIO State Machine

- Работает независимо от ARM ядра
- Частота: до 133 МГц (зависит от разгона RP2040)
- Детерминированный timing для сигналов шины
- FIFO для обмена данными с ARM

## TODO (Фаза 2)

- [ ] Обработка BHE для byte операций (сейчас только word)
- [ ] Расширение RAM до 256KB
- [ ] Обработка сигналов INTR/INTA для прерываний
- [ ] Дополнительные I/O устройства (UART, PIT, PIC)
- [ ] Оптимизация производительности (zero-wait states, DMA)

## Сборка проекта

```bash
mkdir build
cd build
cmake ..
make
```

Результат: `MultiIO.uf2` для загрузки на RP2040

## Требования

- Pico SDK
- CMake >= 3.13
- GCC ARM toolchain
- Китайская фиолетовая плата RP2040 (все 30 GPIO доступны)

## Подключение к i8086

| RP2040 GPIO | i8086 Pin | Описание |
|-------------|-----------|----------|
| 2 | ALE | Address Latch Enable |
| 3 | Декодер адреса | Chip Select (от декодера) |
| 6 | WR | Write strobe |
| 7 | RD | Read strobe |
| 8-15 | AD0-AD7 | Мультиплексированная адрес/данные |
| 20 | READY | Wait state control |
| 21 | INTR | Interrupt request |
| 29 | CLK | Clock input (TODO) |

**Примечание**: Для полноценной работы потребуется:
- Внешний адресный защелка (74HC573 или аналог) для мультиплексированной шины
- Декодер адресов для генерации CS
- Подтягивающие резисторы на критичных сигналах

## Лицензия

Не указана
